# BVH 算法

BVH 是基于物体的细分算法，它的大意如下：

![1](05-04/1.png)

- 它的根节点就是整个场景
- 叶子节点就是 primitive
- 如果 Ray Insert 不与子节点相交，子树就会被忽略
- 每个子节点，即每个 primitive 只出现一次

这里提供了 BVH 树的算法，总共 4 种。

![2](05-04/2.png)

- SAH： 表面积启发算法，默认值
- HLBVH：构建树的效率低于 SAH，但是更适合并发
- Middle，EqualCounts：更少的计算量，但是构建的树的精度不高

## BVH流程

bvh的流程主要分三步

- 计算所有的 primitive 的 bounding，并存在一个数组中
- 根据算法来构建一颗二叉树，每个叶子节点有着对 一个或者多个 primitive 的引用
- 将树转化为更紧凑的无指针的表达模式（更加紧凑

![3](05-04/3.png)

![4](05-04/4.png)

这是用到的数据结构

![5](05-04/5.png)

这是第一步

![6](05-04/6.png)

开始递归处理，叶子节点非常好处理

![7](05-04/7.png)

选一条最长的边，尽可能少的 overlape

![8](05-04/8.png)

![9](05-04/9.png)

这里分别讲解不同的，将一堆 primInfo 拆分成两类的算法

### Mid

直接取平均值, 用 C++ 和 lambda, 一个函数就可以搞定

![10](05-04/10.png)

但是有一种情况无法处理：

![11](05-04/11.png)

- a 情况，用 Mid 处理非常合适
- b 情况，这种方式就不是很好了，因为2个子节点有重叠的地方（做BVH遍历的时候，就需要遍历更多
- c 情况，这个才应该是 b 情况的划分方式，这样在做渲染时（BVH遍历），我们的消耗会更少

### 中位数

在Mid不能分割的情况下，只能去中位数，而且，这里，只关心重心位置，不关心 Bound

所以只能减少少部分的消耗

![12](05-04/12.png)

## SAH 表面积启发





 